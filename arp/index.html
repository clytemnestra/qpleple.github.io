<p>--- layout: post title: ! &#39;ARP poisoning : sniffer une communication&#39;
tags: - Blah blah - French status: publish type: post published: true
meta: _edit_last: &#39;1&#39; _wp_old_slug:
arp-poisoning-sniffer-une-communication --- Cet article présente comment
un ordinateur peut écouter tout le trafic entrant et sortant de
n&#39;importe quel ordinateur de son sous-réseau. On ne peut pas vraiment
s&#39;en protéger, il faut juste savoir que ça existe. Rassurez vous, même
si un pirate peut voir tout votre flux internet même le crypté, il ne
pourra pas décoder les flux sécurisés. Cela englobe tout ce que est
HTTPS (site où un petit cadenas s&#39;affiche dans le navigateur), SSH,
etc... Rassurez vous, votre mot de passe bancaire est bien protégé !</p>

<hr>

<p>Il faut être dans le même sous-réseau que l&#39;une au moins des deux
extrémités de la communication, qui sera alors notre cible. Pour
l&#39;exemple, les adresses se terminant par 1 sont celles de la passerelle,
par 2 sont celles de la cible et par 3 sont les notres. Les commandes
présentées ici peuvent être tapées sous Linux ou Mac. Nemesis est un
utilitaire qui permet de construire et d&#39;injecter dans le réseau des
paquets de différents protocoles (dans notre cas ARP). Pour obtenir
l&#39;utilitaire nemesis sous Mac, vous pouvez par exemple <a href="http://www.macports.org/install.php">utiliser
MacPorts</a>.</p>

<hr>

<h2>Principe</h2>

<p>Les communications dans un même sous-réseau se font avec les adresses
MAC (niveau 2), les adresses IP (niveau 3) étant en quelques sorte
utilisées pour acheminer les paquets vers le bon sous-réseau. Or
lorsqu&#39;un ordinateur (192.168.0.3 par exemple) veut envoyer un paquet à
un destinataire (192.168.0.2 par exemple) de son sous-réseau pour la
première fois, il ne connait en général que son adresse IP. Il va donc
envoyer à tout le monde sur le sous-réseau un message du type (requête
ARP) :</p>

<blockquote>
<p>Quelle a l&#39;adresse MAC de 192.168.0.2 ? Répondre à 192.168.0.3.</p>
</blockquote>

<p>et 192.168.0.2 va se reconnaitre et répondre un message du type :</p>

<blockquote>
<p>192.168.0.2 a l&#39;adresse MAC 00:00:00:00:00:03</p>
</blockquote>

<p>L&#39;expéditeur obtient ainsi l&#39;adresse MAC du destinataire et peux lui
envoyer le paquet. Pour éviter d&#39;envoyer des requêtes ARP à chaque fois
qu&#39;on doit envoyer un paquet, les systèmes gardent les correspondances
IP-MAC en cache dans la table ARP. Le principe de l&#39;ARP poisoning est
d&#39;envoyer de faux paquets qui vont modifier la table ARP de la cible et
fausser les correspondances IP-MAC. Dans notre cas, on :</p>

<ul>
<li>  chez la passerelle, associer l&#39;adresse IP de la cible avec notre
adresse MAC</li>
<li>  chez la cible, associer l&#39;adresse IP de la passerelle avec notre
adresse MAC</li>
</ul>

<p>Tous les paquets vont donc nous arriver dessus, il suffira ensuite de
les faire suivre au bon destinataire.</p>

<hr>

<p>1</p>

<p>Prendre l&#39;identité de la cible auprès de la passerelle en envoyant à la
passerelle des paquets qui signifient :</p>

<blockquote>
<p>Je suis la cible (192.168.0.2) et mon adresse MAC est
00:00:00:00:00:03</p>
</blockquote>

<p>c&#39;est notre adresse MAC ! Ceci se fait avec la commande <code>nemesis</code> entrée
avec les options suivantes :</p>

<ul>
<li>  <code>-S 192.168.0.2</code> IP source, celle de la cible</li>
<li>  <code>-D 192.168.0.1</code> IP de destination, celle de la passerelle</li>
<li>  <code>-H 00:00:00:00:00:03</code> MAC source, la notre !</li>
<li>  <code>-M 00:00:00:00:00:01</code> MAC de destination, celle de la passerelle</li>
<li>  <code>-r</code> ARP reply</li>
<li>  <code>-v</code> mode verbose</li>
<li>  <code>-d eth0</code> interface réseau</li>
</ul>

<p>Comme la passerelle redonne régulièrement à tout le sous-réseau son
adresse MAC (encore par un message ARP), ce paquet doit être réinjecté
régulièrement à l&#39;aide par exemple d&#39;une boucle qui répète toutes les 2
secondes la commande <code>commande</code> :</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">while true; do commande; sleep 2; done;
</code></pre></div>
<hr>

<p>2</p>

<p>Prendre l&#39;identité de la passerelle auprès de la cible en envoyant à la
passerelle des paquets qui signifient :</p>

<blockquote>
<p>Je suis la passerelle (192.168.0.1) et mon adresse MAC est
00:00:00:00:00:03</p>
</blockquote>

<p>c&#39;est encore notre adresse MAC ! Ceci se fait avec la commande <code>nemesis</code>
entrée avec les options suivantes :</p>

<ul>
<li>  <code>-S 192.168.0.1</code> IP source, celle de la passerelle</li>
<li>  <code>-D 192.168.0.2</code> IP de destination, celle de la cible</li>
<li>  <code>-H 00:00:00:00:00:03</code> MAC source, la notre !</li>
<li>  <code>-M 00:00:00:00:00:02</code> MAC de destination, celle de la cible</li>
<li>  <code>-r</code> ARP reply</li>
<li>  <code>-v</code> mode verbose</li>
<li>  <code>-d eth0</code> interface réseau</li>
</ul>

<p>De la même façon, il faut que ce paquet soit régulièrement injecté dans
le réseau en utilisant par exemple une boucle comme à l&#39;étape 1.</p>

<hr>

<p>3</p>

<p>A ce stade là, tous les paquets envoyés par la cible (resp. la
passerelle) à la passerelle (resp. la cible) sont adressés à notre
adresse MAC et donc nous parviennent. Nous sommes donc en mesure de les
lire. Cependant, notre système ouvre ces paquets qui lui sont adressés
au niveau 2 (adresses MAC) et constate qu&#39;ils ne lui sont pas adressés
au niveau 3 (adresses IP) et donc les ignore. Le destinataire final
n&#39;obtiendra donc jamais le paquet et ne pourra pas continuer à naviguer.
Il suffit simplement de demander au système de faire suivre vers leur
distinataire final les paquets qui ne nous sommes pas addressés. Il faut
pour cela activer la redirection de paquet :</p>

<ul>
<li><p>Sous Linux :</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">echo 1 &gt; /proc/sys/net/ipv4/ip_forward
</code></pre></div></li>
<li><p>Sous Mac :</p>
<div class="highlight"><pre><code class="text language-text" data-lang="text">sysctl -w net.inet.ip.forwarding=1
</code></pre></div></li>
</ul>
